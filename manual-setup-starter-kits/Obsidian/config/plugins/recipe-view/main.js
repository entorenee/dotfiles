/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RecipeViewPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/recipe-view.ts
var import_obsidian4 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
var always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function set_custom_element_data_map(node, data_map) {
  Object.keys(data_map).forEach((key) => {
    set_custom_element_data(node, key, data_map[key]);
  });
}
function set_custom_element_data(node, prop, value) {
  if (prop in node) {
    node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
  } else {
    attr(node, prop, value);
  }
}
function set_dynamic_element_data(tag) {
  return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
var crossorigin;
function is_crossorigin() {
  if (crossorigin === void 0) {
    crossorigin = false;
    try {
      if (typeof window !== "undefined" && window.parent) {
        void window.parent.document;
      }
    } catch (error) {
      crossorigin = true;
    }
  }
  return crossorigin;
}
function add_iframe_resize_listener(node, fn) {
  const computed_style = getComputedStyle(node);
  if (computed_style.position === "static") {
    node.style.position = "relative";
  }
  const iframe = element("iframe");
  iframe.setAttribute(
    "style",
    "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;"
  );
  iframe.setAttribute("aria-hidden", "true");
  iframe.tabIndex = -1;
  const crossorigin2 = is_crossorigin();
  let unsubscribe;
  if (crossorigin2) {
    iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>";
    unsubscribe = listen(
      window,
      "message",
      /** @param {MessageEvent} event */
      (event) => {
        if (event.source === iframe.contentWindow)
          fn();
      }
    );
  } else {
    iframe.src = "about:blank";
    iframe.onload = () => {
      unsubscribe = listen(iframe.contentWindow, "resize", fn);
      fn();
    };
  }
  append(node, iframe);
  return () => {
    if (crossorigin2) {
      unsubscribe();
    } else if (unsubscribe && iframe.contentWindow) {
      unsubscribe();
    }
    detach(iframe);
  };
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}
function construct_svelte_component(component, props) {
  return new component(props);
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block7, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block7(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance11, create_fragment11, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance11 ? instance11(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment11 ? create_fragment11($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/RecipeCard.svelte
var import_obsidian3 = require("obsidian");

// src/RecipeCardTitleBlock.svelte
var import_obsidian = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-12o875y", ".title-block.svelte-12o875y.svelte-12o875y{display:flex;flex-direction:row;margin-block-end:var(--size-4-8)}img.thumbnail.svelte-12o875y.svelte-12o875y{height:var(--thumbnail-size);width:var(--thumbnail-size);object-fit:cover;flex:0 0 var(--thumbnail-size);margin-inline-end:var(--size-4-4);border-radius:var(--radius-s)}.frontmatter.svelte-12o875y.svelte-12o875y{display:flex;flex-direction:flex-row;flex-wrap:wrap;justify-content:start;gap:var(--size-2-1) var(--size-4-4)}.title-block-property.svelte-12o875y.svelte-12o875y{display:inline-block;font-size:var(--font-small)}.key.svelte-12o875y.svelte-12o875y{color:var(--text-accent);padding-right:var(--size-4-1);font-weight:500}.single-column.title-block.svelte-12o875y.svelte-12o875y{flex-direction:column;justify-content:start;align-items:start}.single-column.svelte-12o875y img.thumbnail.svelte-12o875y{margin-bottom:var(--size-4-4)}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i][0];
  child_ctx[9] = list[i][1];
  return child_ctx;
}
function create_if_block_2(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "thumbnail svelte-12o875y");
      if (!src_url_equal(img.src, img_src_value = /*thumbnailPath*/
      ctx[0]))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = "Thumbnail for " + /*title*/
      ctx[1] + " recipe");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*thumbnailPath*/
      1 && !src_url_equal(img.src, img_src_value = /*thumbnailPath*/
      ctx2[0])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*title*/
      2 && img_alt_value !== (img_alt_value = "Thumbnail for " + /*title*/
      ctx2[1] + " recipe")) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_if_block(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(Object.entries(
    /*frontmatter*/
    ctx[2]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, frontmatter, formatFrontmatterValue*/
      20) {
        each_value = ensure_array_like(Object.entries(
          /*frontmatter*/
          ctx2[2]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let span2;
  let span0;
  let t0_value = (
    /*key*/
    ctx[8] + ""
  );
  let t0;
  let span0_data_property_key_value;
  let t1;
  let span1;
  let raw_value = (
    /*formatFrontmatterValue*/
    ctx[4](
      /*key*/
      ctx[8],
      /*value*/
      ctx[9]
    ) + ""
  );
  let span1_data_property_value_value;
  let t2;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = space();
      attr(span0, "class", "key svelte-12o875y");
      attr(span0, "data-property-key", span0_data_property_key_value = /*key*/
      ctx[8]);
      attr(span1, "class", "value");
      attr(span1, "data-property-value", span1_data_property_value_value = /*value*/
      ctx[9]);
      attr(span2, "class", "title-block-property svelte-12o875y");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span0, t0);
      append(span2, t1);
      append(span2, span1);
      span1.innerHTML = raw_value;
      append(span2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*frontmatter*/
      4 && t0_value !== (t0_value = /*key*/
      ctx2[8] + ""))
        set_data(t0, t0_value);
      if (dirty & /*frontmatter*/
      4 && span0_data_property_key_value !== (span0_data_property_key_value = /*key*/
      ctx2[8])) {
        attr(span0, "data-property-key", span0_data_property_key_value);
      }
      if (dirty & /*frontmatter*/
      4 && raw_value !== (raw_value = /*formatFrontmatterValue*/
      ctx2[4](
        /*key*/
        ctx2[8],
        /*value*/
        ctx2[9]
      ) + ""))
        span1.innerHTML = raw_value;
      ;
      if (dirty & /*frontmatter*/
      4 && span1_data_property_value_value !== (span1_data_property_value_value = /*value*/
      ctx2[9])) {
        attr(span1, "data-property-value", span1_data_property_value_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span2);
      }
    }
  };
}
function create_each_block(ctx) {
  let show_if = (
    /*formatFrontmatterValue*/
    ctx[4](
      /*key*/
      ctx[8],
      /*value*/
      ctx[9]
    )
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block_1(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*frontmatter*/
      4)
        show_if = /*formatFrontmatterValue*/
        ctx2[4](
          /*key*/
          ctx2[8],
          /*value*/
          ctx2[9]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment(ctx) {
  let div3;
  let t0;
  let div2;
  let div0;
  let t1;
  let t2;
  let div1;
  let if_block0 = (
    /*thumbnailPath*/
    ctx[0] && create_if_block_2(ctx)
  );
  let if_block1 = (
    /*frontmatter*/
    ctx[2] && create_if_block(ctx)
  );
  return {
    c() {
      div3 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div2 = element("div");
      div0 = element("div");
      t1 = text(
        /*title*/
        ctx[1]
      );
      t2 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "inline-title");
      attr(div1, "class", "frontmatter svelte-12o875y");
      attr(div2, "class", "metadata");
      attr(div3, "class", "title-block svelte-12o875y");
      toggle_class(
        div3,
        "single-column",
        /*singleColumn*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t0);
      append(div3, div2);
      append(div2, div0);
      append(div0, t1);
      append(div2, t2);
      append(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
    },
    p(ctx2, [dirty]) {
      if (
        /*thumbnailPath*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(div3, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*title*/
      2)
        set_data(
          t1,
          /*title*/
          ctx2[1]
        );
      if (
        /*frontmatter*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*singleColumn*/
      8) {
        toggle_class(
          div3,
          "single-column",
          /*singleColumn*/
          ctx2[3]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { thumbnailPath } = $$props;
  let { title } = $$props;
  let { frontmatter } = $$props;
  let { singleColumn } = $$props;
  let { app } = $$props;
  let { file } = $$props;
  let { view } = $$props;
  function formatFrontmatterValue(key, value) {
    var _a;
    try {
      let url = new URL(value);
      return createEl("a", { href: url.toString(), text: url.host }).outerHTML;
    } catch (e) {
    }
    if (key == "tags") {
      return value.map((tag) => {
        let a = createEl("a", {
          cls: "tag",
          href: "#" + tag,
          text: "#" + tag
        });
        a.setAttribute("target", "_blank");
        a.setAttribute("rel", "noopener");
        return a.outerHTML;
      }).join(" ");
    }
    if (typeof value === "string" || value instanceof String) {
      const markdownContainer = createSpan();
      import_obsidian.MarkdownRenderer.render(app, value.toString(), markdownContainer, file.path, view);
      return ((_a = markdownContainer.children.item(0)) == null ? void 0 : _a.innerHTML) || "-";
    }
    return void 0;
  }
  $$self.$$set = ($$props2) => {
    if ("thumbnailPath" in $$props2)
      $$invalidate(0, thumbnailPath = $$props2.thumbnailPath);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("frontmatter" in $$props2)
      $$invalidate(2, frontmatter = $$props2.frontmatter);
    if ("singleColumn" in $$props2)
      $$invalidate(3, singleColumn = $$props2.singleColumn);
    if ("app" in $$props2)
      $$invalidate(5, app = $$props2.app);
    if ("file" in $$props2)
      $$invalidate(6, file = $$props2.file);
    if ("view" in $$props2)
      $$invalidate(7, view = $$props2.view);
  };
  return [
    thumbnailPath,
    title,
    frontmatter,
    singleColumn,
    formatFrontmatterValue,
    app,
    file,
    view
  ];
}
var RecipeCardTitleBlock = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        thumbnailPath: 0,
        title: 1,
        frontmatter: 2,
        singleColumn: 3,
        app: 5,
        file: 6,
        view: 7
      },
      add_css
    );
  }
};
var RecipeCardTitleBlock_default = RecipeCardTitleBlock;

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/store.ts
var plugin = writable();
var counter = writable(0);
var store_default = { plugin, counter };

// node_modules/fraction.js/fraction.js
var MAX_CYCLE_LEN = 2e3;
var P = {
  "s": 1,
  "n": 0,
  "d": 1
};
function assign2(n, s) {
  if (isNaN(n = parseInt(n, 10))) {
    throw InvalidParameter();
  }
  return n * s;
}
function newFraction(n, d) {
  if (d === 0) {
    throw DivisionByZero();
  }
  var f = Object.create(Fraction.prototype);
  f["s"] = n < 0 ? -1 : 1;
  n = n < 0 ? -n : n;
  var a = gcd(n, d);
  f["n"] = n / a;
  f["d"] = d / a;
  return f;
}
function factorize(num) {
  var factors = {};
  var n = num;
  var i = 2;
  var s = 4;
  while (s <= n) {
    while (n % i === 0) {
      n /= i;
      factors[i] = (factors[i] || 0) + 1;
    }
    s += 1 + 2 * i++;
  }
  if (n !== num) {
    if (n > 1)
      factors[n] = (factors[n] || 0) + 1;
  } else {
    factors[num] = (factors[num] || 0) + 1;
  }
  return factors;
}
var parse = function(p1, p2) {
  var n = 0, d = 1, s = 1;
  var v = 0, w = 0, x = 0, y = 1, z = 1;
  var A = 0, B = 1;
  var C = 1, D = 1;
  var N = 1e7;
  var M;
  if (p1 === void 0 || p1 === null) {
  } else if (p2 !== void 0) {
    n = p1;
    d = p2;
    s = n * d;
    if (n % 1 !== 0 || d % 1 !== 0) {
      throw NonIntegerParameter();
    }
  } else
    switch (typeof p1) {
      case "object": {
        if ("d" in p1 && "n" in p1) {
          n = p1["n"];
          d = p1["d"];
          if ("s" in p1)
            n *= p1["s"];
        } else if (0 in p1) {
          n = p1[0];
          if (1 in p1)
            d = p1[1];
        } else {
          throw InvalidParameter();
        }
        s = n * d;
        break;
      }
      case "number": {
        if (p1 < 0) {
          s = p1;
          p1 = -p1;
        }
        if (p1 % 1 === 0) {
          n = p1;
        } else if (p1 > 0) {
          if (p1 >= 1) {
            z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
            p1 /= z;
          }
          while (B <= N && D <= N) {
            M = (A + C) / (B + D);
            if (p1 === M) {
              if (B + D <= N) {
                n = A + C;
                d = B + D;
              } else if (D > B) {
                n = C;
                d = D;
              } else {
                n = A;
                d = B;
              }
              break;
            } else {
              if (p1 > M) {
                A += C;
                B += D;
              } else {
                C += A;
                D += B;
              }
              if (B > N) {
                n = C;
                d = D;
              } else {
                n = A;
                d = B;
              }
            }
          }
          n *= z;
        } else if (isNaN(p1) || isNaN(p2)) {
          d = n = NaN;
        }
        break;
      }
      case "string": {
        B = p1.match(/\d+|./g);
        if (B === null)
          throw InvalidParameter();
        if (B[A] === "-") {
          s = -1;
          A++;
        } else if (B[A] === "+") {
          A++;
        }
        if (B.length === A + 1) {
          w = assign2(B[A++], s);
        } else if (B[A + 1] === "." || B[A] === ".") {
          if (B[A] !== ".") {
            v = assign2(B[A++], s);
          }
          A++;
          if (A + 1 === B.length || B[A + 1] === "(" && B[A + 3] === ")" || B[A + 1] === "'" && B[A + 3] === "'") {
            w = assign2(B[A], s);
            y = Math.pow(10, B[A].length);
            A++;
          }
          if (B[A] === "(" && B[A + 2] === ")" || B[A] === "'" && B[A + 2] === "'") {
            x = assign2(B[A + 1], s);
            z = Math.pow(10, B[A + 1].length) - 1;
            A += 3;
          }
        } else if (B[A + 1] === "/" || B[A + 1] === ":") {
          w = assign2(B[A], s);
          y = assign2(B[A + 2], 1);
          A += 3;
        } else if (B[A + 3] === "/" && B[A + 1] === " ") {
          v = assign2(B[A], s);
          w = assign2(B[A + 2], s);
          y = assign2(B[A + 4], 1);
          A += 5;
        }
        if (B.length <= A) {
          d = y * z;
          s = /* void */
          n = x + d * v + z * w;
          break;
        }
      }
      default:
        throw InvalidParameter();
    }
  if (d === 0) {
    throw DivisionByZero();
  }
  P["s"] = s < 0 ? -1 : 1;
  P["n"] = Math.abs(n);
  P["d"] = Math.abs(d);
};
function modpow(b, e, m) {
  var r = 1;
  for (; e > 0; b = b * b % m, e >>= 1) {
    if (e & 1) {
      r = r * b % m;
    }
  }
  return r;
}
function cycleLen(n, d) {
  for (; d % 2 === 0; d /= 2) {
  }
  for (; d % 5 === 0; d /= 5) {
  }
  if (d === 1)
    return 0;
  var rem = 10 % d;
  var t = 1;
  for (; rem !== 1; t++) {
    rem = rem * 10 % d;
    if (t > MAX_CYCLE_LEN)
      return 0;
  }
  return t;
}
function cycleStart(n, d, len) {
  var rem1 = 1;
  var rem2 = modpow(10, len, d);
  for (var t = 0; t < 300; t++) {
    if (rem1 === rem2)
      return t;
    rem1 = rem1 * 10 % d;
    rem2 = rem2 * 10 % d;
  }
  return 0;
}
function gcd(a, b) {
  if (!a)
    return b;
  if (!b)
    return a;
  while (1) {
    a %= b;
    if (!a)
      return b;
    b %= a;
    if (!b)
      return a;
  }
}
function Fraction(a, b) {
  parse(a, b);
  if (this instanceof Fraction) {
    a = gcd(P["d"], P["n"]);
    this["s"] = P["s"];
    this["n"] = P["n"] / a;
    this["d"] = P["d"] / a;
  } else {
    return newFraction(P["s"] * P["n"], P["d"]);
  }
}
var DivisionByZero = function() {
  return new Error("Division by Zero");
};
var InvalidParameter = function() {
  return new Error("Invalid argument");
};
var NonIntegerParameter = function() {
  return new Error("Parameters must be integer");
};
Fraction.prototype = {
  "s": 1,
  "n": 0,
  "d": 1,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  "abs": function() {
    return newFraction(this["n"], this["d"]);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  "neg": function() {
    return newFraction(-this["s"] * this["n"], this["d"]);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  "add": function(a, b) {
    parse(a, b);
    return newFraction(
      this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
      this["d"] * P["d"]
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  "sub": function(a, b) {
    parse(a, b);
    return newFraction(
      this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
      this["d"] * P["d"]
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  "mul": function(a, b) {
    parse(a, b);
    return newFraction(
      this["s"] * P["s"] * this["n"] * P["n"],
      this["d"] * P["d"]
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  "div": function(a, b) {
    parse(a, b);
    return newFraction(
      this["s"] * P["s"] * this["n"] * P["d"],
      this["d"] * P["n"]
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  "clone": function() {
    return newFraction(this["s"] * this["n"], this["d"]);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   **/
  "mod": function(a, b) {
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    if (a === void 0) {
      return newFraction(this["s"] * this["n"] % this["d"], 1);
    }
    parse(a, b);
    if (0 === P["n"] && 0 === this["d"]) {
      throw DivisionByZero();
    }
    return newFraction(
      this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
      P["d"] * this["d"]
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  "gcd": function(a, b) {
    parse(a, b);
    return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  "lcm": function(a, b) {
    parse(a, b);
    if (P["n"] === 0 && this["n"] === 0) {
      return newFraction(0, 1);
    }
    return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  "ceil": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  "floor": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Rounds a rational numbers
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  "round": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  "inverse": function() {
    return newFraction(this["s"] * this["d"], this["n"]);
  },
  /**
   * Calculates the fraction to some rational exponent, if possible
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  "pow": function(a, b) {
    parse(a, b);
    if (P["d"] === 1) {
      if (P["s"] < 0) {
        return newFraction(Math.pow(this["s"] * this["d"], P["n"]), Math.pow(this["n"], P["n"]));
      } else {
        return newFraction(Math.pow(this["s"] * this["n"], P["n"]), Math.pow(this["d"], P["n"]));
      }
    }
    if (this["s"] < 0)
      return null;
    var N = factorize(this["n"]);
    var D = factorize(this["d"]);
    var n = 1;
    var d = 1;
    for (var k in N) {
      if (k === "1")
        continue;
      if (k === "0") {
        n = 0;
        break;
      }
      N[k] *= P["n"];
      if (N[k] % P["d"] === 0) {
        N[k] /= P["d"];
      } else
        return null;
      n *= Math.pow(k, N[k]);
    }
    for (var k in D) {
      if (k === "1")
        continue;
      D[k] *= P["n"];
      if (D[k] % P["d"] === 0) {
        D[k] /= P["d"];
      } else
        return null;
      d *= Math.pow(k, D[k]);
    }
    if (P["s"] < 0) {
      return newFraction(d, n);
    }
    return newFraction(n, d);
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  "equals": function(a, b) {
    parse(a, b);
    return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"];
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  "compare": function(a, b) {
    parse(a, b);
    var t = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
    return (0 < t) - (t < 0);
  },
  "simplify": function(eps) {
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return this;
    }
    eps = eps || 1e-3;
    var thisABS = this["abs"]();
    var cont = thisABS["toContinued"]();
    for (var i = 1; i < cont.length; i++) {
      var s = newFraction(cont[i - 1], 1);
      for (var k = i - 2; k >= 0; k--) {
        s = s["inverse"]()["add"](cont[k]);
      }
      if (Math.abs(s["sub"](thisABS).valueOf()) < eps) {
        return s["mul"](this["s"]);
      }
    }
    return this;
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  "divisible": function(a, b) {
    parse(a, b);
    return !(!(P["n"] * this["d"]) || this["n"] * P["d"] % (P["n"] * this["d"]));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  "valueOf": function() {
    return this["s"] * this["n"] / this["d"];
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
   **/
  "toFraction": function(excludeWhole) {
    var whole, str = "";
    var n = this["n"];
    var d = this["d"];
    if (this["s"] < 0) {
      str += "-";
    }
    if (d === 1) {
      str += n;
    } else {
      if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
        str += whole;
        str += " ";
        n %= d;
      }
      str += n;
      str += "/";
      str += d;
    }
    return str;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  "toLatex": function(excludeWhole) {
    var whole, str = "";
    var n = this["n"];
    var d = this["d"];
    if (this["s"] < 0) {
      str += "-";
    }
    if (d === 1) {
      str += n;
    } else {
      if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
        str += whole;
        n %= d;
      }
      str += "\\frac{";
      str += n;
      str += "}{";
      str += d;
      str += "}";
    }
    return str;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  "toContinued": function() {
    var t;
    var a = this["n"];
    var b = this["d"];
    var res = [];
    if (isNaN(a) || isNaN(b)) {
      return res;
    }
    do {
      res.push(Math.floor(a / b));
      t = a % b;
      a = b;
      b = t;
    } while (a !== 1);
    return res;
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  "toString": function(dec) {
    var N = this["n"];
    var D = this["d"];
    if (isNaN(N) || isNaN(D)) {
      return "NaN";
    }
    dec = dec || 15;
    var cycLen = cycleLen(N, D);
    var cycOff = cycleStart(N, D, cycLen);
    var str = this["s"] < 0 ? "-" : "";
    str += N / D | 0;
    N %= D;
    N *= 10;
    if (N)
      str += ".";
    if (cycLen) {
      for (var i = cycOff; i--; ) {
        str += N / D | 0;
        N %= D;
        N *= 10;
      }
      str += "(";
      for (var i = cycLen; i--; ) {
        str += N / D | 0;
        N %= D;
        N *= 10;
      }
      str += ")";
    } else {
      for (var i = dec; N && i--; ) {
        str += N / D | 0;
        N %= D;
        N *= 10;
      }
    }
    return str;
  }
};

// src/ScaleSelector.svelte
function add_css2(target) {
  append_styles(target, "svelte-1f8v6rc", 'div.svelte-1f8v6rc{width:100%;text-align:center;font-size:var(--font-smaller);background-color:var(--background-secondary);padding:var(--size-4-2);margin-block-end:var(--size-4-4);border-radius:var(--radius-s);color:var(--text-muted)}input.svelte-1f8v6rc{width:var(--size-4-16);border:none;background-color:hsla(\n			var(--accent-h),\n			var(--accent-s),\n			var(--accent-l),\n			var(--selected-step-alpha)\n		);margin-inline-start:var(--size-4-2);text-align:right;font-size:var(--font-smaller);height:var(--size-4-8)}label.svelte-1f8v6rc{margin-right:calc(-1 * var(--size-4-2))}label.svelte-1f8v6rc::after{content:"\xD7";position:relative;width:var(--size-4-4);right:calc(var(--size-4-16) - var(--size-4-2));color:var(--text-accent)}');
}
function create_fragment2(ctx) {
  let div;
  let label;
  let t;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      label = element("label");
      t = text("Scale recipe ");
      input = element("input");
      attr(input, "type", "number");
      attr(input, "inputmode", "decimal");
      attr(input, "min", "0");
      attr(input, "class", "svelte-1f8v6rc");
      attr(label, "class", "svelte-1f8v6rc");
      attr(div, "class", "svelte-1f8v6rc");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t);
      append(label, input);
      set_input_value(
        input,
        /*scaleNum*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "blur",
            /*blur_handler*/
            ctx[2]
          ),
          listen(
            input,
            "focus",
            /*focus_handler*/
            ctx[3]
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*scaleNum*/
      1 && to_number(input.value) !== /*scaleNum*/
      ctx2[0]) {
        set_input_value(
          input,
          /*scaleNum*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { scaleNum = 1 } = $$props;
  let { scale } = $$props;
  const blur_handler = () => $$invalidate(0, scaleNum = scaleNum || 1);
  const focus_handler = () => $$invalidate(0, scaleNum = scaleNum == 1 ? null : scaleNum);
  function input_input_handler() {
    scaleNum = to_number(this.value);
    $$invalidate(0, scaleNum);
  }
  $$self.$$set = ($$props2) => {
    if ("scaleNum" in $$props2)
      $$invalidate(0, scaleNum = $$props2.scaleNum);
    if ("scale" in $$props2)
      $$invalidate(1, scale = $$props2.scale);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*scaleNum*/
    1) {
      $:
        $$invalidate(1, scale = new Fraction(scaleNum || 1));
    }
  };
  return [scaleNum, scale, blur_handler, focus_handler, input_input_handler];
}
var ScaleSelector = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { scaleNum: 0, scale: 1 }, add_css2);
  }
};
var ScaleSelector_default = ScaleSelector;

// src/RecipeLeaf.svelte
function create_dynamic_element(ctx) {
  let svelte_element;
  return {
    c() {
      svelte_element = element(
        /*asTag*/
        ctx[0]
      );
      set_dynamic_element_data(
        /*asTag*/
        ctx[0]
      )(svelte_element, { class: "recipe-leaf" });
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      ctx[3](svelte_element);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
      ctx[3](null);
    }
  };
}
function create_fragment3(ctx) {
  let div;
  let previous_tag = (
    /*asTag*/
    ctx[0]
  );
  let svelte_element = (
    /*asTag*/
    ctx[0] && create_dynamic_element(ctx)
  );
  return {
    c() {
      div = element("div");
      if (svelte_element)
        svelte_element.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (svelte_element)
        svelte_element.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (
        /*asTag*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*asTag*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(div, null);
        } else if (safe_not_equal(
          previous_tag,
          /*asTag*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*asTag*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(div, null);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*asTag*/
        ctx2[0];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { childNodesOf } = $$props;
  let { asTag } = $$props;
  let root;
  onMount(() => {
    Array.from(childNodesOf.childNodes).forEach((node) => {
      root.appendChild(node);
    });
    for (var dataAttr in childNodesOf.dataset) {
      root.setAttr("data-" + dataAttr, childNodesOf.dataset[dataAttr]);
    }
    return () => {
      if (root)
        Array.from(root.childNodes).forEach((node) => {
          childNodesOf.appendChild(node);
        });
    };
  });
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      root = $$value;
      $$invalidate(1, root);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("childNodesOf" in $$props2)
      $$invalidate(2, childNodesOf = $$props2.childNodesOf);
    if ("asTag" in $$props2)
      $$invalidate(0, asTag = $$props2.asTag);
  };
  return [asTag, root, childNodesOf, svelte_element_binding];
}
var RecipeLeaf = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { childNodesOf: 2, asTag: 0 });
  }
};
var RecipeLeaf_default = RecipeLeaf;

// src/CheckableIngredientList.svelte
function add_css3(target) {
  append_styles(target, "svelte-lcqxt7", 'ul.svelte-lcqxt7.svelte-lcqxt7{padding-inline-start:0}input[type="checkbox"].svelte-lcqxt7.svelte-lcqxt7{opacity:0;position:absolute;margin:0;padding:0}label.svelte-lcqxt7.svelte-lcqxt7{position:relative}input[type="checkbox"].svelte-lcqxt7:checked~.leaf.svelte-lcqxt7{color:var(--text-muted);text-decoration:line-through}input[type="checkbox"].svelte-lcqxt7:focus~.leaf.svelte-lcqxt7{color:var(--text-accent-hover)}ul.svelte-lcqxt7>li.svelte-lcqxt7{list-style-type:none;margin-block:var(--list-spacing)}ul.bullets.svelte-lcqxt7>li.svelte-lcqxt7{list-style-type:square;margin-inline-start:var(--list-indent)}');
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_each_block2(ctx) {
  let li;
  let label;
  let input;
  let input_checked_value;
  let t0;
  let div;
  let recipeleaf;
  let t1;
  let current;
  let mounted;
  let dispose;
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx[5](
        /*i*/
        ctx[8],
        ...args
      )
    );
  }
  recipeleaf = new RecipeLeaf_default({
    props: {
      childNodesOf: (
        /*itemAt*/
        ctx[4](
          /*i*/
          ctx[8]
        )
      ),
      asTag: "div"
    }
  });
  return {
    c() {
      li = element("li");
      label = element("label");
      input = element("input");
      t0 = space();
      div = element("div");
      create_component(recipeleaf.$$.fragment);
      t1 = space();
      attr(input, "type", "checkbox");
      input.checked = input_checked_value = /*isChecked*/
      ctx[2](
        /*i*/
        ctx[8]
      );
      attr(input, "class", "svelte-lcqxt7");
      attr(div, "class", "leaf svelte-lcqxt7");
      attr(label, "class", "svelte-lcqxt7");
      attr(li, "class", "svelte-lcqxt7");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, label);
      append(label, input);
      append(label, t0);
      append(label, div);
      mount_component(recipeleaf, div, null);
      append(li, t1);
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(recipeleaf.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipeleaf.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_component(recipeleaf);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment4(ctx) {
  let div;
  let ul;
  let current;
  let each_value = ensure_array_like(
    /*list*/
    ctx[0].children
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(ul, "class", "svelte-lcqxt7");
      toggle_class(
        ul,
        "bullets",
        /*bullets*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*itemAt, isChecked, changeChecked, list*/
      29) {
        each_value = ensure_array_like(
          /*list*/
          ctx2[0].children
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*bullets*/
      2) {
        toggle_class(
          ul,
          "bullets",
          /*bullets*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { list } = $$props;
  let { bullets } = $$props;
  function isChecked(index) {
    var _a;
    return ((_a = list.children.item(index)) == null ? void 0 : _a.getAttr("data-checked")) == "true" || false;
  }
  function changeChecked(index, e) {
    var _a;
    (_a = list.children.item(index)) == null ? void 0 : _a.setAttr("data-checked", e.target.checked ? "true" : "false");
  }
  function itemAt(index) {
    return list.children.item(index);
  }
  const change_handler = (i, e) => changeChecked(i, e);
  $$self.$$set = ($$props2) => {
    if ("list" in $$props2)
      $$invalidate(0, list = $$props2.list);
    if ("bullets" in $$props2)
      $$invalidate(1, bullets = $$props2.bullets);
  };
  return [list, bullets, isChecked, changeChecked, itemAt, change_handler];
}
var CheckableIngredientList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { list: 0, bullets: 1 }, add_css3);
  }
};
var CheckableIngredientList_default = CheckableIngredientList;

// src/SelectableStepList.svelte
function add_css4(target) {
  append_styles(target, "svelte-4j13uv", 'li.svelte-4j13uv.svelte-4j13uv{margin-block:var(--p-spacing)}input[type="radio"].svelte-4j13uv.svelte-4j13uv{opacity:0;position:absolute;height:100%;width:100%;margin:0;padding:0;z-index:-1}label.svelte-4j13uv.svelte-4j13uv{position:relative}.leaf.svelte-4j13uv.svelte-4j13uv{border-radius:var(--radius-m);padding:var(--size-4-2);margin:calc(-1 * var(--size-4-2))}body:not(.is-mobile) li.svelte-4j13uv .leaf.svelte-4j13uv{padding-inline-start:var(--list-indent);margin-inline-start:calc(-1 * var(--list-indent))}input[type="radio"].svelte-4j13uv:checked~.leaf.svelte-4j13uv{background-color:hsla(\n			var(--accent-h),\n			var(--accent-s),\n			var(--accent-l),\n			var(--selected-step-alpha)\n		)}input[type="radio"].svelte-4j13uv:focus~.leaf.svelte-4j13uv{box-shadow:inset 0px 0px 0px var(--border-width)\n			var(--interactive-accent)}');
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_if_block_12(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*pList*/
    ctx[4]()
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*pList, radioName*/
      18) {
        each_value_1 = ensure_array_like(
          /*pList*/
          ctx2[4]()
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block2(ctx) {
  let div;
  let ol;
  let current;
  let each_value = ensure_array_like(
    /*olChildren*/
    ctx[2]()
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      ol = element("ol");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(ol, "class", "recipe-mutex-select");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ol);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ol, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*olChild, radioName*/
      10) {
        each_value = ensure_array_like(
          /*olChildren*/
          ctx2[2]()
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ol, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let div1;
  let p_1;
  let label;
  let input;
  let t0;
  let div0;
  let recipeleaf;
  let t1;
  let current;
  recipeleaf = new RecipeLeaf_default({
    props: { childNodesOf: (
      /*p*/
      ctx[9]
    ), asTag: "div" }
  });
  return {
    c() {
      div1 = element("div");
      p_1 = element("p");
      label = element("label");
      input = element("input");
      t0 = space();
      div0 = element("div");
      create_component(recipeleaf.$$.fragment);
      t1 = space();
      attr(input, "type", "radio");
      attr(
        input,
        "name",
        /*radioName*/
        ctx[1]
      );
      attr(input, "class", "svelte-4j13uv");
      attr(div0, "class", "leaf svelte-4j13uv");
      attr(label, "class", "svelte-4j13uv");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p_1);
      append(p_1, label);
      append(label, input);
      append(label, t0);
      append(label, div0);
      mount_component(recipeleaf, div0, null);
      append(div1, t1);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*radioName*/
      2) {
        attr(
          input,
          "name",
          /*radioName*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(recipeleaf.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipeleaf.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(recipeleaf);
    }
  };
}
function create_each_block3(ctx) {
  let li;
  let label;
  let input;
  let t0;
  let div;
  let recipeleaf;
  let t1;
  let current;
  recipeleaf = new RecipeLeaf_default({
    props: {
      childNodesOf: (
        /*olChild*/
        ctx[3](
          /*i*/
          ctx[8]
        )
      ),
      asTag: "div"
    }
  });
  return {
    c() {
      li = element("li");
      label = element("label");
      input = element("input");
      t0 = space();
      div = element("div");
      create_component(recipeleaf.$$.fragment);
      t1 = space();
      attr(input, "type", "radio");
      attr(
        input,
        "name",
        /*radioName*/
        ctx[1]
      );
      attr(input, "class", "svelte-4j13uv");
      attr(div, "class", "leaf svelte-4j13uv");
      attr(label, "class", "svelte-4j13uv");
      attr(li, "class", "svelte-4j13uv");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, label);
      append(label, input);
      append(label, t0);
      append(label, div);
      mount_component(recipeleaf, div, null);
      append(li, t1);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*radioName*/
      2) {
        attr(
          input,
          "name",
          /*radioName*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(recipeleaf.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipeleaf.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_component(recipeleaf);
    }
  };
}
function create_fragment5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_if_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*kind*/
      ctx2[0] == "ol"
    )
      return 0;
    if (
      /*kind*/
      ctx2[0] == "p"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { list } = $$props;
  let { kind } = $$props;
  let { radioName } = $$props;
  function olChildren() {
    return list.children;
  }
  function olChild(index) {
    return olChildren().item(index);
  }
  function pList() {
    return list;
  }
  $$self.$$set = ($$props2) => {
    if ("list" in $$props2)
      $$invalidate(5, list = $$props2.list);
    if ("kind" in $$props2)
      $$invalidate(0, kind = $$props2.kind);
    if ("radioName" in $$props2)
      $$invalidate(1, radioName = $$props2.radioName);
  };
  return [kind, radioName, olChildren, olChild, pList, list];
}
var SelectableStepList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { list: 5, kind: 0, radioName: 1 }, add_css4);
  }
};
var SelectableStepList_default = SelectableStepList;

// src/parsing.ts
var import_obsidian2 = require("obsidian");

// src/quantities.ts
var NUMBER = new RegExp(/\d+(([\s-]+\d+)?\/\d+|\.\d+)?/);
var UNIT = new RegExp(/tb?sp?s?\.?|tablespoons?|teaspoons?|k?g|(kilo)?grams?|cups?|m?Ls?|millilit(re|er)s?|lit(re|er)s?|(fl.?|fluid)?\s+(oz\.?|ounces?)|pounds?|lbs?\.?|sticks?/i);
var NUMBER_WITH_UNIT = new RegExp("(?<number>" + NUMBER.source + ")\\s*(?<unit>" + UNIT.source + ")\\b", "ig");
var START_NUMBER_ALONE = new RegExp("(?<startnumber>^" + NUMBER.source + ")\\b", "ig");
var QUANTITY = new RegExp(NUMBER_WITH_UNIT.source + "|" + START_NUMBER_ALONE.source, "ig");
function reUnicodeFractions(str) {
  return str.replace(/\b(?<n>\d+)\/(?<d>\d+)\b/ig, (m, $1, $2) => {
    return $1.replaceAll("0", "\u2070").replaceAll("1", "\xB9").replaceAll("2", "\xB2").replaceAll("3", "\xB3").replaceAll("4", "\u2074").replaceAll("5", "\u2075").replaceAll("6", "\u2076").replaceAll("7", "\u2077").replaceAll("8", "\u2078").replaceAll("9", "\u2079") + "\u2044" + $2.replaceAll("0", "\u2080").replaceAll("1", "\u2081").replaceAll("2", "\u2082").replaceAll("3", "\u2083").replaceAll("4", "\u2084").replaceAll("5", "\u2085").replaceAll("6", "\u2086").replaceAll("7", "\u2087").replaceAll("8", "\u2088").replaceAll("9", "\u2089");
  });
}
function quantityStringsToValue(str, unit) {
  return {
    value: new Fraction(str.replace(/[-\s]+/g, " ")),
    format: str.includes("/") || (unit == null ? void 0 : unit.match(/tablespoons?|teaspoons?|tb?sp?s?\.?|cups?|sticks?/i)) || !unit && !str.includes(".") ? 0 /* FRACTION */ : 1 /* DECIMAL */
  };
}
function matchQuantities(str) {
  return Array.from(str.matchAll(QUANTITY)).map((match) => {
    return {
      index: match.index,
      length: match[0].length,
      value: quantityStringsToValue(match.groups.number || match.groups.startnumber, match.groups.unit),
      unit: match.groups.unit || null
    };
  });
}
function formatQuantity(value, format, scale, unicodeFractions) {
  value = value.mul(scale);
  if (format == 0 /* FRACTION */) {
    value = value.d == 3 ? value : new Fraction(Math.round(16 * new Fraction(value).valueOf()), 16);
    return unicodeFractions ? reUnicodeFractions(value.toFraction(true)) : value.toFraction(true);
  } else {
    return value.toString();
  }
}

// src/ScaledQuantity.svelte
function add_css5(target) {
  append_styles(target, "svelte-ipvkjm", ".scaled.svelte-ipvkjm{text-decoration-line:underline;text-decoration-thickness:1px;text-decoration-color:var(--text-accent);text-underline-offset:4px}");
}
function create_if_block3(ctx) {
  let span;
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("\xA0");
      t1 = text(
        /*unit*/
        ctx[3]
      );
      attr(span, "class", "scale-unit");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*unit*/
      8)
        set_data(
          t1,
          /*unit*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment6(ctx) {
  let span1;
  let span0;
  let t_value = formatQuantity(
    /*value*/
    ctx[1],
    /*format*/
    ctx[2],
    /*scale*/
    ctx[0],
    /*plugin*/
    ctx[4].settings.renderUnicodeFractions
  ) + "";
  let t;
  let if_block = (
    /*unit*/
    ctx[3] && create_if_block3(ctx)
  );
  return {
    c() {
      var _a;
      span1 = element("span");
      span0 = element("span");
      t = text(t_value);
      if (if_block)
        if_block.c();
      attr(span0, "class", "scale-number");
      attr(span1, "class", "svelte-ipvkjm");
      toggle_class(span1, "scaled", !/*scale*/
      ((_a = ctx[0]) == null ? void 0 : _a.equals(1)) || false);
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, span0);
      append(span0, t);
      if (if_block)
        if_block.m(span1, null);
    },
    p(ctx2, [dirty]) {
      var _a;
      if (dirty & /*value, format, scale, plugin*/
      23 && t_value !== (t_value = formatQuantity(
        /*value*/
        ctx2[1],
        /*format*/
        ctx2[2],
        /*scale*/
        ctx2[0],
        /*plugin*/
        ctx2[4].settings.renderUnicodeFractions
      ) + ""))
        set_data(t, t_value);
      if (
        /*unit*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(span1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*scale*/
      1) {
        toggle_class(span1, "scaled", !/*scale*/
        ((_a = ctx2[0]) == null ? void 0 : _a.equals(1)) || false);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { format } = $$props;
  let { unit } = $$props;
  let { qtyScaleStore } = $$props;
  let { scale = new Fraction(1) } = $$props;
  qtyScaleStore.subscribe((s) => $$invalidate(0, scale = s));
  let plugin2;
  store_default.plugin.subscribe((p) => $$invalidate(4, plugin2 = p));
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("format" in $$props2)
      $$invalidate(2, format = $$props2.format);
    if ("unit" in $$props2)
      $$invalidate(3, unit = $$props2.unit);
    if ("qtyScaleStore" in $$props2)
      $$invalidate(5, qtyScaleStore = $$props2.qtyScaleStore);
    if ("scale" in $$props2)
      $$invalidate(0, scale = $$props2.scale);
  };
  return [scale, value, format, unit, plugin2, qtyScaleStore];
}
var ScaledQuantity = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        value: 1,
        format: 2,
        unit: 3,
        qtyScaleStore: 5,
        scale: 0
      },
      add_css5
    );
  }
};
var ScaledQuantity_default = ScaledQuantity;

// src/parsing.ts
function parseForQty(n, qtyScaleStore) {
  if (n.nodeType == Node.ELEMENT_NODE) {
    if (n.hasAttribute("data-qty") || n.hasAttribute("data-qty-no-parse")) {
      return;
    }
  }
  if (n.nodeType == Node.TEXT_NODE) {
    const parent = n.parentNode;
    let currentIndex = 0;
    n.textContent = n.textContent.normalize("NFKD").replaceAll("\u2044", "/");
    for (const match of matchQuantities(n.textContent)) {
      parent.insertBefore(
        document.createTextNode(
          n.textContent.slice(currentIndex, match.index)
        ),
        n
      );
      const qtyTarget = createEl("span");
      qtyTarget.setAttribute("data-qty", "true");
      parent.insertBefore(qtyTarget, n);
      new ScaledQuantity_default({
        target: qtyTarget,
        props: {
          value: match.value.value,
          format: match.value.format,
          unit: match.unit,
          qtyScaleStore
        }
      });
      currentIndex = (match.index || currentIndex) + match.length;
    }
    parent.insertBefore(
      document.createTextNode(n.textContent.slice(currentIndex)),
      n
    );
    parent.removeChild(n);
  }
  if (n.hasChildNodes()) {
    Array.from(n.childNodes).forEach(
      (c) => parseForQty(c, qtyScaleStore)
    );
  }
}
function injectQuantities(parsedRecipe) {
  parsedRecipe.sections.flatMap((s) => s.sideComponents.concat(s.mainComponents)).map((c) => {
    switch (c.type) {
      case RecipeLeaf_default:
        Array.from(c.props.childNodesOf.querySelectorAll("[data-qty-parse]")).forEach((n) => parseForQty(n, parsedRecipe.qtyScaleStore));
        break;
      case SelectableStepList_default:
        if (c.props.kind == "ol") {
          Array.from(c.props.list.querySelectorAll("[data-qty-parse]")).forEach((n) => parseForQty(n, parsedRecipe.qtyScaleStore));
        } else {
          c.props.list.forEach((p) => {
            Array.from(p.querySelectorAll("[data-qty-parse]")).forEach((n) => parseForQty(n, parsedRecipe.qtyScaleStore));
          });
        }
        break;
      case CheckableIngredientList_default:
        parseForQty(c.props.list, parsedRecipe.qtyScaleStore);
        break;
      default:
        break;
    }
  });
}
function parseRecipeMarkdown(plugin2, text2, path, component) {
  var _a, _b;
  const result = {
    title: "",
    thumbnailPath: "",
    sections: [{
      containsHeader: false,
      sideComponents: [],
      mainComponents: []
    }],
    renderedMarkdownParent: createDiv(),
    qtyScaleStore: writable(new Fraction(1))
  };
  import_obsidian2.MarkdownRenderer.render(plugin2.app, text2, result.renderedMarkdownParent, path, component);
  const radioName = `selectable-steps-${get_store_value(store_default.counter)}`;
  store_default.counter.update((n) => n + 1);
  const sideColumnRegex = RegExp(plugin2.settings.sideColumnRegex, "i");
  let currentSection = 0;
  let currentColumn = "mainComponents";
  let sendToSideUntilLevel = 7;
  for (let i = 0; i < result.renderedMarkdownParent.children.length; i++) {
    const item = result.renderedMarkdownParent.children.item(i);
    if (item.nodeName == "HR") {
      result.sections.push({
        containsHeader: false,
        sideComponents: [],
        mainComponents: []
      });
      currentSection++;
      currentColumn = "mainComponents";
      sendToSideUntilLevel = 7;
      continue;
    }
    if (item.nodeName.match(/H[1-6]/)) {
      const headerLevel = parseInt(item.nodeName.at(1));
      if (plugin2.settings.treatH1AsFilename && headerLevel == 1 && result.sections[currentSection].containsHeader == false) {
        result.title = (item == null ? void 0 : item.textContent) || "";
        continue;
      } else {
        result.sections[currentSection].containsHeader = true;
      }
      if ((_a = item.textContent) == null ? void 0 : _a.match(sideColumnRegex)) {
        currentColumn = "sideComponents";
        sendToSideUntilLevel = headerLevel;
      } else if (currentColumn == "sideComponents" && headerLevel <= sendToSideUntilLevel) {
        currentColumn = "mainComponents";
        sendToSideUntilLevel = 7;
      }
    }
    if (item.matches("pre.frontmatter")) {
      continue;
    }
    if (item.getElementsByTagName("IMG").length > 0 && currentSection == 0 && !result.thumbnailPath && !result.sections[0].containsHeader) {
      result.thumbnailPath = ((_b = item.getElementsByTagName("IMG").item(0)) == null ? void 0 : _b.getAttribute("src")) || "";
      continue;
    }
    if (item.nodeName == "UL" && (currentColumn == "sideComponents" || !result.sections[currentSection].containsHeader)) {
      result.sections[currentSection]["sideComponents"].push({
        type: CheckableIngredientList_default,
        props: { list: item, bullets: false },
        origIndex: i
      });
      continue;
    }
    if (item.nodeName == "OL" && currentColumn == "mainComponents") {
      result.sections[currentSection][currentColumn].push({
        type: SelectableStepList_default,
        props: {
          list: item,
          kind: "ol",
          radioName
        },
        origIndex: i
      });
      continue;
    }
    if (item.nodeName == "P" && currentColumn == "mainComponents") {
      const prev = result.sections[currentSection][currentColumn][result.sections[currentSection][currentColumn].length - 1];
      if (prev && prev.type == SelectableStepList_default && prev.props.kind == "p") {
        prev.props.list.push(item);
      } else {
        result.sections[currentSection][currentColumn].push({
          type: SelectableStepList_default,
          props: {
            list: [item],
            kind: "p",
            radioName
          },
          origIndex: i
        });
      }
      continue;
    }
    if (item.hasClass("callout")) {
      const calloutWrapper = createDiv();
      calloutWrapper.appendChild(item);
      result.sections[currentSection][currentColumn].push({
        type: RecipeLeaf_default,
        props: { childNodesOf: calloutWrapper, asTag: "div" },
        origIndex: i
      });
      i -= 1;
      continue;
    }
    result.sections[currentSection][currentColumn].push({
      type: RecipeLeaf_default,
      props: { childNodesOf: item, asTag: item.nodeName },
      origIndex: i
    });
  }
  injectQuantities(result);
  return result;
}

// src/RecipeCardTwoColumn.svelte
function add_css6(target) {
  append_styles(target, "svelte-xf5f8b", ".recipe-card.svelte-xf5f8b{display:flex;flex-direction:row;align-items:stretch;justify-content:center;height:100%;overflow:clip;position:relative;top:0;left:0;right:0;bottom:0}.column.svelte-xf5f8b{padding:var(--file-margins);max-height:100%;overflow-y:auto}.column-side.svelte-xf5f8b{flex-basis:calc(var(--file-line-width) / 2);flex-grow:0;flex-shrink:1}.column-main.svelte-xf5f8b{flex-basis:var(--file-line-width);flex-grow:0;flex-shrink:1}.split-step.svelte-xf5f8b{padding-inline:var(--file-margins);margin-inline:calc(-1 * var(--file-margins));padding-block:calc(var(--file-margins) / 2)}.split-step-title.svelte-xf5f8b{background-color:transparent !important}.split-step.svelte-xf5f8b:nth-child(odd){background-color:var(--background-secondary)}.split-step.only-step.svelte-xf5f8b{background-color:transparent !important}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
var get_titleblock_slot_changes = (dirty) => ({});
var get_titleblock_slot_context = (ctx) => ({});
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
var get_scaleselector_slot_changes = (dirty) => ({});
var get_scaleselector_slot_context = (ctx) => ({});
function create_each_block_2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*c*/
    ctx[7].props
  ];
  var switch_value = (
    /*c*/
    ctx[7].type
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*sideColumnComponents*/
    1) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*c*/
        ctx2[7].props
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*sideColumnComponents*/
      1 && switch_value !== (switch_value = /*c*/
      ctx2[7].type)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*sideColumnComponents*/
        1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*c*/
          ctx2[7].props
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_each_block_12(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*c*/
    ctx[7].props
  ];
  var switch_value = (
    /*c*/
    ctx[7].type
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*mainColumnSections*/
    2) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*c*/
        ctx2[7].props
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*mainColumnSections*/
      2 && switch_value !== (switch_value = /*c*/
      ctx2[7].type)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*mainColumnSections*/
        2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*c*/
          ctx2[7].props
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_each_block4(ctx) {
  let div;
  let t;
  let current;
  let each_value_1 = ensure_array_like(
    /*mainColumnComponents*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr(div, "class", "split-step svelte-xf5f8b");
      toggle_class(
        div,
        "only-step",
        /*mainColumnSections*/
        ctx[1].length == 1
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*mainColumnSections*/
      2) {
        each_value_1 = ensure_array_like(
          /*mainColumnComponents*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*mainColumnSections*/
      2) {
        toggle_class(
          div,
          "only-step",
          /*mainColumnSections*/
          ctx2[1].length == 1
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment7(ctx) {
  let div3;
  let div0;
  let t0;
  let t1;
  let div2;
  let div1;
  let t2;
  let current;
  const scaleselector_slot_template = (
    /*#slots*/
    ctx[3].scaleselector
  );
  const scaleselector_slot = create_slot(
    scaleselector_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_scaleselector_slot_context
  );
  let each_value_2 = ensure_array_like(
    /*sideColumnComponents*/
    ctx[0]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  const titleblock_slot_template = (
    /*#slots*/
    ctx[3].titleblock
  );
  const titleblock_slot = create_slot(
    titleblock_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_titleblock_slot_context
  );
  let each_value = ensure_array_like(
    /*mainColumnSections*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      if (scaleselector_slot)
        scaleselector_slot.c();
      t0 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      if (titleblock_slot)
        titleblock_slot.c();
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "column column-side svelte-xf5f8b");
      attr(div1, "class", "split-step split-step-title svelte-xf5f8b");
      attr(div2, "class", "column column-main svelte-xf5f8b");
      attr(div3, "class", "recipe-card two-column svelte-xf5f8b");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      if (scaleselector_slot) {
        scaleselector_slot.m(div0, null);
      }
      append(div0, t0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div0, null);
        }
      }
      append(div3, t1);
      append(div3, div2);
      append(div2, div1);
      if (titleblock_slot) {
        titleblock_slot.m(div1, null);
      }
      append(div2, t2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (scaleselector_slot) {
        if (scaleselector_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            scaleselector_slot,
            scaleselector_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              scaleselector_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_scaleselector_slot_changes
            ),
            get_scaleselector_slot_context
          );
        }
      }
      if (dirty & /*sideColumnComponents*/
      1) {
        each_value_2 = ensure_array_like(
          /*sideColumnComponents*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_2(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (titleblock_slot) {
        if (titleblock_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            titleblock_slot,
            titleblock_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              titleblock_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_titleblock_slot_changes
            ),
            get_titleblock_slot_context
          );
        }
      }
      if (dirty & /*mainColumnSections*/
      2) {
        each_value = ensure_array_like(
          /*mainColumnSections*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(scaleselector_slot, local);
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      transition_in(titleblock_slot, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(scaleselector_slot, local);
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      transition_out(titleblock_slot, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (scaleselector_slot)
        scaleselector_slot.d(detaching);
      destroy_each(each_blocks_1, detaching);
      if (titleblock_slot)
        titleblock_slot.d(detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { sideColumnComponents } = $$props;
  let { mainColumnSections } = $$props;
  $$self.$$set = ($$props2) => {
    if ("sideColumnComponents" in $$props2)
      $$invalidate(0, sideColumnComponents = $$props2.sideColumnComponents);
    if ("mainColumnSections" in $$props2)
      $$invalidate(1, mainColumnSections = $$props2.mainColumnSections);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [sideColumnComponents, mainColumnSections, $$scope, slots];
}
var RecipeCardTwoColumn = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        sideColumnComponents: 0,
        mainColumnSections: 1
      },
      add_css6
    );
  }
};
var RecipeCardTwoColumn_default = RecipeCardTwoColumn;

// src/RecipeCardSplitSteps.svelte
function add_css7(target) {
  append_styles(target, "svelte-1if9rve", ".split-step.svelte-1if9rve{display:flex;flex-direction:row;justify-content:center;align-items:stretch;padding-block:calc(var(--file-margins) / 2)}.split-step.svelte-1if9rve:nth-child(odd){background-color:var(--background-secondary)}.split-step-title.svelte-1if9rve{padding:var(--file-margins);background-color:transparent !important}.split-steps.svelte-1if9rve{padding-block:var(--file-margins)}.column.svelte-1if9rve{padding-inline:var(--file-margins);display:block}.column.svelte-1if9rve:empty{display:none}.column-side.svelte-1if9rve{flex-basis:calc(var(--file-line-width) / 2);flex-grow:0;flex-shrink:1}.column-main.svelte-1if9rve{flex-basis:var(--file-line-width);flex-grow:0;flex-shrink:1}.column-content.svelte-1if9rve{position:-webkit-sticky;position:sticky;top:var(--file-margins)}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function get_each_context_22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
var get_scaleselector_slot_changes2 = (dirty) => ({});
var get_scaleselector_slot_context2 = (ctx) => ({});
var get_titleblock_slot_changes2 = (dirty) => ({});
var get_titleblock_slot_context2 = (ctx) => ({});
function create_if_block4(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*sections*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*sections*/
      1) {
        each_value = ensure_array_like(
          /*sections*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_22(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*c*/
    ctx[6].props
  ];
  var switch_value = (
    /*c*/
    ctx[6].type
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*sections*/
    1) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*c*/
        ctx2[6].props
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*sections*/
      1 && switch_value !== (switch_value = /*c*/
      ctx[6].type)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*sections*/
        1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*c*/
          ctx[6].props
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_each_block_13(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*c*/
    ctx[6].props
  ];
  var switch_value = (
    /*c*/
    ctx[6].type
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*sections*/
    1) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*c*/
        ctx2[6].props
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*sections*/
      1 && switch_value !== (switch_value = /*c*/
      ctx[6].type)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*sections*/
        1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*c*/
          ctx[6].props
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_each_block5(ctx) {
  let div4;
  let div1;
  let div0;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t0;
  let div3;
  let div2;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let current;
  let each_value_2 = ensure_array_like(
    /*section*/
    ctx[3].sideComponents
  );
  const get_key = (ctx2) => (
    /*c*/
    ctx2[6]
  );
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_22(ctx, each_value_2, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_22(key, child_ctx));
  }
  let each_value_1 = ensure_array_like(
    /*section*/
    ctx[3].mainComponents
  );
  const get_key_1 = (ctx2) => (
    /*c*/
    ctx2[6]
  );
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_13(ctx, each_value_1, i);
    let key = get_key_1(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block_13(key, child_ctx));
  }
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t0 = space();
      div3 = element("div");
      div2 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      attr(div0, "class", "column-content svelte-1if9rve");
      attr(div1, "class", "column column-side svelte-1if9rve");
      attr(div2, "class", "column-content svelte-1if9rve");
      attr(div3, "class", "column column-main svelte-1if9rve");
      attr(div4, "class", "split-step svelte-1if9rve");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div1);
      append(div1, div0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div0, null);
        }
      }
      append(div4, t0);
      append(div4, div3);
      append(div3, div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append(div4, t1);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*sections*/
      1) {
        each_value_2 = ensure_array_like(
          /*section*/
          ctx2[3].sideComponents
        );
        group_outros();
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_2, each0_lookup, div0, outro_and_destroy_block, create_each_block_22, null, get_each_context_22);
        check_outros();
      }
      if (dirty & /*sections*/
      1) {
        each_value_1 = ensure_array_like(
          /*section*/
          ctx2[3].mainComponents
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value_1, each1_lookup, div2, outro_and_destroy_block, create_each_block_13, null, get_each_context_13);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_fragment8(ctx) {
  let div3;
  let div2;
  let div0;
  let t0;
  let div1;
  let t1;
  let t2;
  let current;
  const titleblock_slot_template = (
    /*#slots*/
    ctx[2].titleblock
  );
  const titleblock_slot = create_slot(
    titleblock_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_titleblock_slot_context2
  );
  const scaleselector_slot_template = (
    /*#slots*/
    ctx[2].scaleselector
  );
  const scaleselector_slot = create_slot(
    scaleselector_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_scaleselector_slot_context2
  );
  let if_block = (
    /*sections*/
    ctx[0] && create_if_block4(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      if (titleblock_slot)
        titleblock_slot.c();
      t1 = space();
      if (scaleselector_slot)
        scaleselector_slot.c();
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "column column-side svelte-1if9rve");
      attr(div1, "class", "column column-main svelte-1if9rve");
      attr(div2, "class", "split-step split-step-title svelte-1if9rve");
      attr(div3, "class", "recipe-card split-steps svelte-1if9rve");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t0);
      append(div2, div1);
      if (titleblock_slot) {
        titleblock_slot.m(div1, null);
      }
      append(div1, t1);
      if (scaleselector_slot) {
        scaleselector_slot.m(div1, null);
      }
      append(div3, t2);
      if (if_block)
        if_block.m(div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (titleblock_slot) {
        if (titleblock_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            titleblock_slot,
            titleblock_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              titleblock_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_titleblock_slot_changes2
            ),
            get_titleblock_slot_context2
          );
        }
      }
      if (scaleselector_slot) {
        if (scaleselector_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            scaleselector_slot,
            scaleselector_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              scaleselector_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_scaleselector_slot_changes2
            ),
            get_scaleselector_slot_context2
          );
        }
      }
      if (
        /*sections*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*sections*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(titleblock_slot, local);
      transition_in(scaleselector_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(titleblock_slot, local);
      transition_out(scaleselector_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (titleblock_slot)
        titleblock_slot.d(detaching);
      if (scaleselector_slot)
        scaleselector_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { sections } = $$props;
  $$self.$$set = ($$props2) => {
    if ("sections" in $$props2)
      $$invalidate(0, sections = $$props2.sections);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [sections, $$scope, slots];
}
var RecipeCardSplitSteps = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, { sections: 0 }, add_css7);
  }
};
var RecipeCardSplitSteps_default = RecipeCardSplitSteps;

// src/RecipeCardOneColumn.svelte
function add_css8(target) {
  append_styles(target, "svelte-9mal4k", ".split-step.svelte-9mal4k{display:flex;flex-direction:row;justify-content:center;padding-block:var(--size-4-4)}.split-step-title.svelte-9mal4k{background-color:transparent !important}.split-step.svelte-9mal4k:nth-child(odd){background-color:var(--background-secondary)}.split-step.only-step.svelte-9mal4k{background-color:transparent !important}.column-main.svelte-9mal4k{flex-basis:var(--file-line-width);flex-grow:0;flex-shrink:1}.column.svelte-9mal4k{padding-inline:var(--file-margins)}.column-title.svelte-9mal4k{padding-bottom:0}");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function get_each_context_14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
var get_scaleselector_slot_changes3 = (dirty) => ({});
var get_scaleselector_slot_context3 = (ctx) => ({});
var get_titleblock_slot_changes3 = (dirty) => ({});
var get_titleblock_slot_context3 = (ctx) => ({});
function create_if_block5(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*sections*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*sections*/
      1) {
        each_value = ensure_array_like(
          /*sections*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_14(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*c*/
    ctx[6].props,
    { bullets: true }
  ];
  var switch_value = (
    /*c*/
    ctx[6].type
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*sections*/
    1) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*c*/
        ctx2[6].props
      ), switch_instance_spread_levels[1]]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*sections*/
      1 && switch_value !== (switch_value = /*c*/
      ctx[6].type)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*sections*/
        1 ? get_spread_update(switch_instance_spread_levels, [
          get_spread_object(
            /*c*/
            ctx[6].props
          ),
          switch_instance_spread_levels[1]
        ]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_each_block6(ctx) {
  let div1;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let current;
  let each_value_1 = ensure_array_like(
    /*section*/
    ctx[3]
  );
  const get_key = (ctx2) => (
    /*c*/
    ctx2[6]
  );
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_14(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_14(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr(div0, "class", "column column-main svelte-9mal4k");
      attr(div1, "class", "split-step svelte-9mal4k");
      toggle_class(
        div1,
        "only-step",
        /*sections*/
        ctx[0].length == 1
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div1, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*sections*/
      1) {
        each_value_1 = ensure_array_like(
          /*section*/
          ctx2[3]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, div0, outro_and_destroy_block, create_each_block_14, null, get_each_context_14);
        check_outros();
      }
      if (!current || dirty & /*sections*/
      1) {
        toggle_class(
          div1,
          "only-step",
          /*sections*/
          ctx2[0].length == 1
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_fragment9(ctx) {
  let div2;
  let div1;
  let div0;
  let t0;
  let t1;
  let current;
  const titleblock_slot_template = (
    /*#slots*/
    ctx[2].titleblock
  );
  const titleblock_slot = create_slot(
    titleblock_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_titleblock_slot_context3
  );
  const scaleselector_slot_template = (
    /*#slots*/
    ctx[2].scaleselector
  );
  const scaleselector_slot = create_slot(
    scaleselector_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_scaleselector_slot_context3
  );
  let if_block = (
    /*sections*/
    ctx[0] && create_if_block5(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (titleblock_slot)
        titleblock_slot.c();
      t0 = space();
      if (scaleselector_slot)
        scaleselector_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "column column-main column-title svelte-9mal4k");
      attr(div1, "class", "split-step split-step-title svelte-9mal4k");
      attr(div2, "class", "recipe-card one-column");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      if (titleblock_slot) {
        titleblock_slot.m(div0, null);
      }
      append(div0, t0);
      if (scaleselector_slot) {
        scaleselector_slot.m(div0, null);
      }
      append(div2, t1);
      if (if_block)
        if_block.m(div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (titleblock_slot) {
        if (titleblock_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            titleblock_slot,
            titleblock_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              titleblock_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_titleblock_slot_changes3
            ),
            get_titleblock_slot_context3
          );
        }
      }
      if (scaleselector_slot) {
        if (scaleselector_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            scaleselector_slot,
            scaleselector_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              scaleselector_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_scaleselector_slot_changes3
            ),
            get_scaleselector_slot_context3
          );
        }
      }
      if (
        /*sections*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*sections*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(titleblock_slot, local);
      transition_in(scaleselector_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(titleblock_slot, local);
      transition_out(scaleselector_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (titleblock_slot)
        titleblock_slot.d(detaching);
      if (scaleselector_slot)
        scaleselector_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { sections } = $$props;
  $$self.$$set = ($$props2) => {
    if ("sections" in $$props2)
      $$invalidate(0, sections = $$props2.sections);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [sections, $$scope, slots];
}
var RecipeCardOneColumn = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, { sections: 0 }, add_css8);
  }
};
var RecipeCardOneColumn_default = RecipeCardOneColumn;

// src/RecipeCard.svelte
function add_css9(target) {
  append_styles(target, "svelte-1vw9jtd", ".container.svelte-1vw9jtd{position:relative;top:0;left:0;right:0;height:100%;width:100%;display:block}.recipe-card div:has(> .frontmatter-section){display:none}");
}
function create_else_block(ctx) {
  var _a;
  let recipecardsplitsteps;
  let current;
  recipecardsplitsteps = new RecipeCardSplitSteps_default({
    props: {
      sections: (
        /*parsedRecipe*/
        (_a = ctx[0]) == null ? void 0 : _a.sections
      ),
      $$slots: {
        titleblock: [create_titleblock_slot_2],
        scaleselector: [create_scaleselector_slot_2]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(recipecardsplitsteps.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recipecardsplitsteps, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const recipecardsplitsteps_changes = {};
      if (dirty & /*parsedRecipe*/
      1)
        recipecardsplitsteps_changes.sections = /*parsedRecipe*/
        (_a2 = ctx2[0]) == null ? void 0 : _a2.sections;
      if (dirty & /*$$scope, title, frontmatter, parsedRecipe, plugin, file, view, qtyScale, scaleNum*/
      268436319) {
        recipecardsplitsteps_changes.$$scope = { dirty, ctx: ctx2 };
      }
      recipecardsplitsteps.$set(recipecardsplitsteps_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recipecardsplitsteps.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipecardsplitsteps.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recipecardsplitsteps, detaching);
    }
  };
}
function create_if_block_13(ctx) {
  let recipecardtwocolumn;
  let current;
  recipecardtwocolumn = new RecipeCardTwoColumn_default({
    props: {
      sideColumnComponents: (
        /*twoColumnSideComponents*/
        ctx[12]
      ),
      mainColumnSections: (
        /*twoColumnMainComponents*/
        ctx[11]
      ),
      $$slots: {
        titleblock: [create_titleblock_slot_1],
        scaleselector: [create_scaleselector_slot_1]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(recipecardtwocolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recipecardtwocolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recipecardtwocolumn_changes = {};
      if (dirty & /*twoColumnSideComponents*/
      4096)
        recipecardtwocolumn_changes.sideColumnComponents = /*twoColumnSideComponents*/
        ctx2[12];
      if (dirty & /*twoColumnMainComponents*/
      2048)
        recipecardtwocolumn_changes.mainColumnSections = /*twoColumnMainComponents*/
        ctx2[11];
      if (dirty & /*$$scope, title, frontmatter, parsedRecipe, plugin, file, view, qtyScale, scaleNum*/
      268436319) {
        recipecardtwocolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      recipecardtwocolumn.$set(recipecardtwocolumn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recipecardtwocolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipecardtwocolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recipecardtwocolumn, detaching);
    }
  };
}
function create_if_block6(ctx) {
  let recipecardonecolumn;
  let current;
  recipecardonecolumn = new RecipeCardOneColumn_default({
    props: {
      sections: (
        /*singleColumnSections*/
        ctx[10]
      ),
      $$slots: {
        titleblock: [create_titleblock_slot],
        scaleselector: [create_scaleselector_slot]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(recipecardonecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recipecardonecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recipecardonecolumn_changes = {};
      if (dirty & /*singleColumnSections*/
      1024)
        recipecardonecolumn_changes.sections = /*singleColumnSections*/
        ctx2[10];
      if (dirty & /*$$scope, title, frontmatter, parsedRecipe, plugin, file, view, qtyScale, scaleNum*/
      268436319) {
        recipecardonecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      recipecardonecolumn.$set(recipecardonecolumn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recipecardonecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipecardonecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recipecardonecolumn, detaching);
    }
  };
}
function create_scaleselector_slot_2(ctx) {
  let scaleselector;
  let updating_scale;
  let updating_scaleNum;
  let current;
  function scaleselector_scale_binding_2(value) {
    ctx[20](value);
  }
  function scaleselector_scaleNum_binding_2(value) {
    ctx[21](value);
  }
  let scaleselector_props = { slot: "scaleselector" };
  if (
    /*qtyScale*/
    ctx[4] !== void 0
  ) {
    scaleselector_props.scale = /*qtyScale*/
    ctx[4];
  }
  if (
    /*scaleNum*/
    ctx[6] !== void 0
  ) {
    scaleselector_props.scaleNum = /*scaleNum*/
    ctx[6];
  }
  scaleselector = new ScaleSelector_default({ props: scaleselector_props });
  binding_callbacks.push(() => bind(scaleselector, "scale", scaleselector_scale_binding_2));
  binding_callbacks.push(() => bind(scaleselector, "scaleNum", scaleselector_scaleNum_binding_2));
  return {
    c() {
      create_component(scaleselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(scaleselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const scaleselector_changes = {};
      if (!updating_scale && dirty & /*qtyScale*/
      16) {
        updating_scale = true;
        scaleselector_changes.scale = /*qtyScale*/
        ctx2[4];
        add_flush_callback(() => updating_scale = false);
      }
      if (!updating_scaleNum && dirty & /*scaleNum*/
      64) {
        updating_scaleNum = true;
        scaleselector_changes.scaleNum = /*scaleNum*/
        ctx2[6];
        add_flush_callback(() => updating_scaleNum = false);
      }
      scaleselector.$set(scaleselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scaleselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scaleselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(scaleselector, detaching);
    }
  };
}
function create_titleblock_slot_2(ctx) {
  var _a;
  let recipecardtitleblock;
  let current;
  recipecardtitleblock = new RecipeCardTitleBlock_default({
    props: {
      slot: "titleblock",
      title: (
        /*title*/
        ctx[9]
      ),
      frontmatter: (
        /*frontmatter*/
        ctx[8]
      ),
      thumbnailPath: (
        /*parsedRecipe*/
        (_a = ctx[0]) == null ? void 0 : _a.thumbnailPath
      ),
      singleColumn: false,
      app: (
        /*plugin*/
        ctx[3].app
      ),
      file: (
        /*file*/
        ctx[1]
      ),
      view: (
        /*view*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(recipecardtitleblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recipecardtitleblock, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const recipecardtitleblock_changes = {};
      if (dirty & /*title*/
      512)
        recipecardtitleblock_changes.title = /*title*/
        ctx2[9];
      if (dirty & /*frontmatter*/
      256)
        recipecardtitleblock_changes.frontmatter = /*frontmatter*/
        ctx2[8];
      if (dirty & /*parsedRecipe*/
      1)
        recipecardtitleblock_changes.thumbnailPath = /*parsedRecipe*/
        (_a2 = ctx2[0]) == null ? void 0 : _a2.thumbnailPath;
      if (dirty & /*plugin*/
      8)
        recipecardtitleblock_changes.app = /*plugin*/
        ctx2[3].app;
      if (dirty & /*file*/
      2)
        recipecardtitleblock_changes.file = /*file*/
        ctx2[1];
      if (dirty & /*view*/
      4)
        recipecardtitleblock_changes.view = /*view*/
        ctx2[2];
      recipecardtitleblock.$set(recipecardtitleblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recipecardtitleblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipecardtitleblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recipecardtitleblock, detaching);
    }
  };
}
function create_scaleselector_slot_1(ctx) {
  let scaleselector;
  let updating_scale;
  let updating_scaleNum;
  let current;
  function scaleselector_scale_binding_1(value) {
    ctx[18](value);
  }
  function scaleselector_scaleNum_binding_1(value) {
    ctx[19](value);
  }
  let scaleselector_props = { slot: "scaleselector" };
  if (
    /*qtyScale*/
    ctx[4] !== void 0
  ) {
    scaleselector_props.scale = /*qtyScale*/
    ctx[4];
  }
  if (
    /*scaleNum*/
    ctx[6] !== void 0
  ) {
    scaleselector_props.scaleNum = /*scaleNum*/
    ctx[6];
  }
  scaleselector = new ScaleSelector_default({ props: scaleselector_props });
  binding_callbacks.push(() => bind(scaleselector, "scale", scaleselector_scale_binding_1));
  binding_callbacks.push(() => bind(scaleselector, "scaleNum", scaleselector_scaleNum_binding_1));
  return {
    c() {
      create_component(scaleselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(scaleselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const scaleselector_changes = {};
      if (!updating_scale && dirty & /*qtyScale*/
      16) {
        updating_scale = true;
        scaleselector_changes.scale = /*qtyScale*/
        ctx2[4];
        add_flush_callback(() => updating_scale = false);
      }
      if (!updating_scaleNum && dirty & /*scaleNum*/
      64) {
        updating_scaleNum = true;
        scaleselector_changes.scaleNum = /*scaleNum*/
        ctx2[6];
        add_flush_callback(() => updating_scaleNum = false);
      }
      scaleselector.$set(scaleselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scaleselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scaleselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(scaleselector, detaching);
    }
  };
}
function create_titleblock_slot_1(ctx) {
  var _a;
  let recipecardtitleblock;
  let current;
  recipecardtitleblock = new RecipeCardTitleBlock_default({
    props: {
      slot: "titleblock",
      title: (
        /*title*/
        ctx[9]
      ),
      frontmatter: (
        /*frontmatter*/
        ctx[8]
      ),
      thumbnailPath: (
        /*parsedRecipe*/
        (_a = ctx[0]) == null ? void 0 : _a.thumbnailPath
      ),
      singleColumn: false,
      app: (
        /*plugin*/
        ctx[3].app
      ),
      file: (
        /*file*/
        ctx[1]
      ),
      view: (
        /*view*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(recipecardtitleblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recipecardtitleblock, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const recipecardtitleblock_changes = {};
      if (dirty & /*title*/
      512)
        recipecardtitleblock_changes.title = /*title*/
        ctx2[9];
      if (dirty & /*frontmatter*/
      256)
        recipecardtitleblock_changes.frontmatter = /*frontmatter*/
        ctx2[8];
      if (dirty & /*parsedRecipe*/
      1)
        recipecardtitleblock_changes.thumbnailPath = /*parsedRecipe*/
        (_a2 = ctx2[0]) == null ? void 0 : _a2.thumbnailPath;
      if (dirty & /*plugin*/
      8)
        recipecardtitleblock_changes.app = /*plugin*/
        ctx2[3].app;
      if (dirty & /*file*/
      2)
        recipecardtitleblock_changes.file = /*file*/
        ctx2[1];
      if (dirty & /*view*/
      4)
        recipecardtitleblock_changes.view = /*view*/
        ctx2[2];
      recipecardtitleblock.$set(recipecardtitleblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recipecardtitleblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipecardtitleblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recipecardtitleblock, detaching);
    }
  };
}
function create_scaleselector_slot(ctx) {
  let scaleselector;
  let updating_scale;
  let updating_scaleNum;
  let current;
  function scaleselector_scale_binding(value) {
    ctx[16](value);
  }
  function scaleselector_scaleNum_binding(value) {
    ctx[17](value);
  }
  let scaleselector_props = { slot: "scaleselector" };
  if (
    /*qtyScale*/
    ctx[4] !== void 0
  ) {
    scaleselector_props.scale = /*qtyScale*/
    ctx[4];
  }
  if (
    /*scaleNum*/
    ctx[6] !== void 0
  ) {
    scaleselector_props.scaleNum = /*scaleNum*/
    ctx[6];
  }
  scaleselector = new ScaleSelector_default({ props: scaleselector_props });
  binding_callbacks.push(() => bind(scaleselector, "scale", scaleselector_scale_binding));
  binding_callbacks.push(() => bind(scaleselector, "scaleNum", scaleselector_scaleNum_binding));
  return {
    c() {
      create_component(scaleselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(scaleselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const scaleselector_changes = {};
      if (!updating_scale && dirty & /*qtyScale*/
      16) {
        updating_scale = true;
        scaleselector_changes.scale = /*qtyScale*/
        ctx2[4];
        add_flush_callback(() => updating_scale = false);
      }
      if (!updating_scaleNum && dirty & /*scaleNum*/
      64) {
        updating_scaleNum = true;
        scaleselector_changes.scaleNum = /*scaleNum*/
        ctx2[6];
        add_flush_callback(() => updating_scaleNum = false);
      }
      scaleselector.$set(scaleselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scaleselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scaleselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(scaleselector, detaching);
    }
  };
}
function create_titleblock_slot(ctx) {
  var _a;
  let recipecardtitleblock;
  let current;
  recipecardtitleblock = new RecipeCardTitleBlock_default({
    props: {
      slot: "titleblock",
      title: (
        /*title*/
        ctx[9]
      ),
      frontmatter: (
        /*frontmatter*/
        ctx[8]
      ),
      thumbnailPath: (
        /*parsedRecipe*/
        (_a = ctx[0]) == null ? void 0 : _a.thumbnailPath
      ),
      singleColumn: true,
      app: (
        /*plugin*/
        ctx[3].app
      ),
      file: (
        /*file*/
        ctx[1]
      ),
      view: (
        /*view*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(recipecardtitleblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recipecardtitleblock, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const recipecardtitleblock_changes = {};
      if (dirty & /*title*/
      512)
        recipecardtitleblock_changes.title = /*title*/
        ctx2[9];
      if (dirty & /*frontmatter*/
      256)
        recipecardtitleblock_changes.frontmatter = /*frontmatter*/
        ctx2[8];
      if (dirty & /*parsedRecipe*/
      1)
        recipecardtitleblock_changes.thumbnailPath = /*parsedRecipe*/
        (_a2 = ctx2[0]) == null ? void 0 : _a2.thumbnailPath;
      if (dirty & /*plugin*/
      8)
        recipecardtitleblock_changes.app = /*plugin*/
        ctx2[3].app;
      if (dirty & /*file*/
      2)
        recipecardtitleblock_changes.file = /*file*/
        ctx2[1];
      if (dirty & /*view*/
      4)
        recipecardtitleblock_changes.view = /*view*/
        ctx2[2];
      recipecardtitleblock.$set(recipecardtitleblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recipecardtitleblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipecardtitleblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recipecardtitleblock, detaching);
    }
  };
}
function create_fragment10(ctx) {
  let div;
  let show_if;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let div_resize_listener;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block6, create_if_block_13, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    var _a;
    if (dirty & /*isBelowSingleColumnWidth, twoColumnSideComponents, twoColumnMainComponents*/
    14336)
      show_if = null;
    if (show_if == null)
      show_if = !!/*isBelowSingleColumnWidth*/
      (ctx2[13] != false || /*twoColumnSideComponents*/
      ctx2[12].length == 0 || /*twoColumnMainComponents*/
      ctx2[11].flat().length == 0);
    if (show_if)
      return 0;
    if (
      /*parsedRecipe*/
      ((_a = ctx2[0]) == null ? void 0 : _a.sections.length) <= 3
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      var _a, _b;
      div = element("div");
      if_block.c();
      attr(div, "class", div_class_value = null_to_empty(
        /*frontmatter*/
        (_b = (_a = ctx[8]) == null ? void 0 : _a.cssclasses) == null ? void 0 : _b.join(" ")
      ) + " svelte-1vw9jtd");
      attr(div, "role", "document");
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[22].call(div)
      ));
      toggle_class(div, "container", true);
      toggle_class(div, "markdown-rendered", true);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[22].bind(div)
      );
      ctx[23](div);
      current = true;
      if (!mounted) {
        dispose = listen(
          div,
          "keypress",
          /*handleKeypress*/
          ctx[14]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a, _b;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*frontmatter*/
      256 && div_class_value !== (div_class_value = null_to_empty(
        /*frontmatter*/
        (_b = (_a = ctx2[8]) == null ? void 0 : _a.cssclasses) == null ? void 0 : _b.join(" ")
      ) + " svelte-1vw9jtd")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*frontmatter*/
      256) {
        toggle_class(div, "container", true);
      }
      if (!current || dirty & /*frontmatter*/
      256) {
        toggle_class(div, "markdown-rendered", true);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
      div_resize_listener();
      ctx[23](null);
      mounted = false;
      dispose();
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let isBelowSingleColumnWidth;
  let twoColumnSideComponents;
  let twoColumnMainComponents;
  let singleColumnSections;
  let title;
  let frontmatter;
  let plugin2;
  store_default.plugin.subscribe((p) => $$invalidate(3, plugin2 = p));
  let { parsedRecipe } = $$props;
  let { metadata } = $$props;
  let { file } = $$props;
  let { view } = $$props;
  let scaleNum = 1;
  let qtyScale;
  let containerWidth;
  let container;
  function checkNext(focusOnly) {
    const nextUnchecked = container.querySelector("input[type=checkbox]:not(:checked)");
    if (nextUnchecked) {
      if (!focusOnly)
        nextUnchecked.checked = true;
      nextUnchecked.focus();
    }
  }
  function uncheckPrevious() {
    const checked = container.querySelectorAll("input[type=checkbox]:checked");
    if (checked.length > 0) {
      const lastChecked = checked.item(checked.length - 1);
      lastChecked.checked = false;
      lastChecked.focus();
    }
  }
  function advanceStep(focusOnly) {
    const steps = container.querySelectorAll("input[type=radio]");
    for (let i = 0; i < steps.length; i++) {
      if (steps.item(i).checked) {
        if (!focusOnly && steps.item(i + 1))
          steps.item(i + 1).checked = true;
        if (focusOnly || steps.item(i + 1))
          steps.item(focusOnly ? i : i + 1).focus();
        return;
      }
    }
    if (!focusOnly)
      steps.item(0).checked = true;
    steps.item(0).focus();
  }
  function retreatStep() {
    const steps = container.querySelectorAll("input[type=radio]");
    for (let i = 1; i < steps.length; i++) {
      if (steps.item(i).checked) {
        steps.item(i - 1).checked = true;
        steps.item(i - 1).focus();
        return;
      }
    }
  }
  function handleKeypress(e) {
    if (e.key == "n") {
      checkNext(false);
    } else if (e.key == "p") {
      uncheckPrevious();
    } else if (e.key == "j") {
      advanceStep(false);
    } else if (e.key == "k") {
      retreatStep();
    } else if (e.key == "[") {
      if (scaleNum) {
        $$invalidate(6, scaleNum -= 0.25);
      } else {
        $$invalidate(6, scaleNum = 0.75);
      }
    } else if (e.key == "]") {
      if (scaleNum) {
        $$invalidate(6, scaleNum += 0.25);
      } else {
        $$invalidate(6, scaleNum = 1.25);
      }
    } else if (e.key == "h") {
      checkNext(true);
    } else if (e.key == "l") {
      advanceStep(true);
    }
  }
  function scaleselector_scale_binding(value) {
    qtyScale = value;
    $$invalidate(4, qtyScale);
  }
  function scaleselector_scaleNum_binding(value) {
    scaleNum = value;
    $$invalidate(6, scaleNum);
  }
  function scaleselector_scale_binding_1(value) {
    qtyScale = value;
    $$invalidate(4, qtyScale);
  }
  function scaleselector_scaleNum_binding_1(value) {
    scaleNum = value;
    $$invalidate(6, scaleNum);
  }
  function scaleselector_scale_binding_2(value) {
    qtyScale = value;
    $$invalidate(4, qtyScale);
  }
  function scaleselector_scaleNum_binding_2(value) {
    scaleNum = value;
    $$invalidate(6, scaleNum);
  }
  function div_elementresize_handler() {
    containerWidth = this.clientWidth;
    $$invalidate(5, containerWidth);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(7, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("parsedRecipe" in $$props2)
      $$invalidate(0, parsedRecipe = $$props2.parsedRecipe);
    if ("metadata" in $$props2)
      $$invalidate(15, metadata = $$props2.metadata);
    if ("file" in $$props2)
      $$invalidate(1, file = $$props2.file);
    if ("view" in $$props2)
      $$invalidate(2, view = $$props2.view);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*parsedRecipe, qtyScale*/
    17) {
      $:
        parsedRecipe == null ? void 0 : parsedRecipe.qtyScaleStore.set(qtyScale);
    }
    if ($$self.$$.dirty & /*containerWidth, plugin*/
    40) {
      $:
        $$invalidate(13, isBelowSingleColumnWidth = containerWidth < plugin2.settings.singleColumnMaxWidth);
    }
    if ($$self.$$.dirty & /*parsedRecipe*/
    1) {
      $:
        $$invalidate(12, twoColumnSideComponents = (parsedRecipe == null ? void 0 : parsedRecipe.sections.flatMap(({ sideComponents }) => sideComponents)) || []);
    }
    if ($$self.$$.dirty & /*parsedRecipe*/
    1) {
      $:
        $$invalidate(11, twoColumnMainComponents = (parsedRecipe == null ? void 0 : parsedRecipe.sections.map(({ mainComponents }) => mainComponents)) || []);
    }
    if ($$self.$$.dirty & /*parsedRecipe*/
    1) {
      $:
        $$invalidate(10, singleColumnSections = parsedRecipe == null ? void 0 : parsedRecipe.sections.map((s) => s.sideComponents.concat(s.mainComponents).sort((a, b) => a.origIndex - b.origIndex)));
    }
    if ($$self.$$.dirty & /*parsedRecipe, file*/
    3) {
      $:
        $$invalidate(9, title = parsedRecipe.title ? parsedRecipe.title : file.basename);
    }
    if ($$self.$$.dirty & /*metadata*/
    32768) {
      $:
        $$invalidate(8, frontmatter = (metadata == null ? void 0 : metadata.frontmatter) || {});
    }
  };
  return [
    parsedRecipe,
    file,
    view,
    plugin2,
    qtyScale,
    containerWidth,
    scaleNum,
    container,
    frontmatter,
    title,
    singleColumnSections,
    twoColumnMainComponents,
    twoColumnSideComponents,
    isBelowSingleColumnWidth,
    handleKeypress,
    metadata,
    scaleselector_scale_binding,
    scaleselector_scaleNum_binding,
    scaleselector_scale_binding_1,
    scaleselector_scaleNum_binding_1,
    scaleselector_scale_binding_2,
    scaleselector_scaleNum_binding_2,
    div_elementresize_handler,
    div_binding
  ];
}
var RecipeCard = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance10,
      create_fragment10,
      safe_not_equal,
      {
        parsedRecipe: 0,
        metadata: 15,
        file: 1,
        view: 2
      },
      add_css9
    );
  }
};
var RecipeCard_default = RecipeCard;

// src/recipe-view.ts
var VIEW_TYPE_RECIPE = "recipe-view";
var RecipeView = class extends import_obsidian4.EditableFileView {
  constructor(leaf, plugin2) {
    super(leaf);
    __publicField(this, "plugin");
    __publicField(this, "content");
    this.plugin = plugin2;
  }
  getViewType() {
    return VIEW_TYPE_RECIPE;
  }
  getDisplayText() {
    var _a;
    return ((_a = this.file) == null ? void 0 : _a.basename) || "Recipe";
  }
  getIcon() {
    return "chef-hat";
  }
  async onOpen() {
    this.renderRecipe();
    this.containerEl.on("mouseover", "a.internal-link", (e, el) => {
      this.app.workspace.trigger("hover-link", {
        event: e,
        source: this,
        hoverParent: this,
        el,
        linktext: el.getAttr("href"),
        sourcePath: this.file.path
      });
    });
    this.containerEl.on("click", "a.internal-link", (e, el) => {
      const inNewLeaf = import_obsidian4.Keymap.isModEvent(e);
      this.app.workspace.openLinkText(
        el.getAttr("href"),
        this.file.path,
        inNewLeaf
      );
    });
    this.containerEl.on("click", "a.tag", (e, el) => {
      this.app.internalPlugins.getPluginById("global-search").instance.openGlobalSearch(`tag:${el.getAttr("href")}`);
    });
  }
  async onClose() {
    var _a;
    (_a = this.content) == null ? void 0 : _a.$destroy();
  }
  async onLoadFile(file) {
    super.onLoadFile(file);
    this.renderRecipe();
    return;
  }
  async renderRecipe() {
    if (!this.file) {
      return false;
    }
    const text2 = await this.app.vault.cachedRead(this.file);
    const metadata = await this.app.metadataCache.getFileCache(this.file);
    const parsedRecipe = parseRecipeMarkdown(this.plugin, text2, this.file.path, this);
    this.content = new RecipeCard_default({
      target: this.contentEl,
      props: {
        parsedRecipe,
        file: this.file,
        metadata: metadata || void 0,
        view: this
      }
    });
    return true;
  }
};

// src/whisk.ts
var WHISK_SVG = `<g transform="scale(4.167)" fill="currentColor"><circle cx="21" cy="3" r="2"/><path d="M17,7c0,0 -4,22 -13,13c-9,-9 13,-13 13,-13Zm-2.649,2.649c-2.523,0.661 -6.092,1.816 -8.511,3.522c-0.984,0.694 -1.804,1.432 -1.976,2.379c-0.167,0.914 0.381,1.867 1.55,3.036c1.169,1.169 2.122,1.717 3.036,1.55c0.947,-0.172 1.685,-0.992 2.379,-1.976c1.706,-2.419 2.861,-5.988 3.522,-8.511Z"/><path d="M15,9l5,-5" stroke="currentColor"/></g>`;

// src/main.ts
var DEFAULT_SETTINGS = {
  sideColumnRegex: "Ingredients|Nutrition",
  treatH1AsFilename: false,
  renderUnicodeFractions: true,
  singleColumnMaxWidth: 600
};
var RecipeViewPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings", DEFAULT_SETTINGS);
  }
  async onload() {
    await this.loadSettings();
    this.registerView(VIEW_TYPE_RECIPE, (leaf) => new RecipeView(leaf, this));
    (0, import_obsidian5.addIcon)("recipe-whisk", WHISK_SVG);
    this.addRibbonIcon("recipe-whisk", "Toggle recipe view", () => {
      this.toggleView(false);
    });
    this.addCommand({
      id: "toggle-recipe-view",
      name: "Toggle between recipe card and markdown",
      checkCallback: (c) => this.toggleView(c)
    });
    this.addSettingTab(new RecipeViewSettingsTab(this.app, this));
    this.app.workspace.trigger("parse-style-settings");
    store_default.plugin.set(this);
  }
  onunload() {
  }
  toggleView(checking) {
    const activeLeaf = this.app.workspace.getMostRecentLeaf();
    if ((activeLeaf == null ? void 0 : activeLeaf.getViewState().type) == "markdown") {
      if (!checking) {
        this.setRecipeView(activeLeaf);
      }
    } else if ((activeLeaf == null ? void 0 : activeLeaf.getViewState().type) == VIEW_TYPE_RECIPE) {
      if (!checking) {
        this.setMarkdownView(activeLeaf);
      }
    } else {
      return false;
    }
    return true;
  }
  async setRecipeView(leaf) {
    await leaf.setViewState({
      type: VIEW_TYPE_RECIPE,
      state: leaf.view.getState(),
      active: true,
      // @ts-ignore
      popstate: true
    });
  }
  async setMarkdownView(leaf) {
    await leaf.setViewState({
      type: "markdown",
      state: leaf.view.getState(),
      active: true,
      // @ts-ignore
      popstate: true
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var RecipeViewSettingsTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin2) {
    super(app, plugin2);
    __publicField(this, "plugin");
    this.plugin = plugin2;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian5.Setting(containerEl).setName("Recipe parsing").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Side column regex").setDesc("A regular expression for headings of sections to pull to the side column").addText((text2) => text2.setPlaceholder("Ingredients|Nutrition").setValue(this.plugin.settings.sideColumnRegex).onChange(async (value) => {
      this.plugin.settings.sideColumnRegex = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Treat level one heading as filename").setDesc('If turned on, then in recipes that have a "# Level one heading", there should only be one \u2013 and it will be used as the recipe title. Turn this on if you usually start your notes with a level one heading that matches the filename, and turn it off if you would ever use headings like "# Ingredients", "# Directons", etc.').addToggle((toggle) => toggle.setValue(this.plugin.settings.treatH1AsFilename).onChange(async (value) => {
      this.plugin.settings.treatH1AsFilename = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Recipe card appearance").setDesc("More options are available using the style settings plugin.").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Render fractions in quantities as unicode").setDesc('If on, fractions will appear like e.g. "\xBD cup". If off, they will appear like e.g. "1/2 cup".').addToggle((toggle) => toggle.setValue(this.plugin.settings.renderUnicodeFractions).onChange(async (value) => {
      this.plugin.settings.renderUnicodeFractions = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Maximum pixel width for single-column view").setDesc("Recipe cards shown wider than this view will switch to two-column layout.").addSlider((slider) => slider.setDynamicTooltip().setLimits(50, 2e3, 10).setValue(this.plugin.settings.singleColumnMaxWidth).onChange(async (value) => {
      this.plugin.settings.singleColumnMaxWidth = value;
      await this.plugin.saveSettings();
    }));
  }
};
/*! Bundled license information:

fraction.js/fraction.js:
  (**
   * @license Fraction.js v4.3.5 31/08/2023
   * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
   *
   * Copyright (c) 2023, Robert Eisele (robert@raw.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)
*/

/* nosourcemap */